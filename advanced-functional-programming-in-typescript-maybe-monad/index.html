<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head><meta name="generator" content="Hexo 3.8.0">

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="With this post, I would like to start a short series about monads. If you are familiar with some functional programming techniques in JavaScript (such">
    

    <!--Author-->
    
        <meta name="author" content="Miłosz Piechocki">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Advanced functional programming in TypeScript: Maybe monad">
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="codewithstyle.info">

    <!--Type page-->
    
        <meta property="og:type" content="article">
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary">
    

    <!-- Title -->
    
    <title>Advanced functional programming in TypeScript: Maybe monad - codewithstyle.info</title>

    <!-- Tachyons Core CSS -->
    <link rel="stylesheet" href="//unpkg.com/tachyons/css/tachyons.min.css">

    <!-- Custom Fonts -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.5.0/css/all.css" integrity="sha384-B4dIYHKNBt8Bc12p+WXckhzcICo0wtJAoU8YZTY5qE0Id1GSseTk6S+L3BlXeVIU" crossorigin="anonymous">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<!-- Main Content -->
<!-- Banner -->
<!-- Banner -->
<div class="w-100 bg-1 text-light">
    
    <div class="w-100">
        <nav class="db flex-l pv3 mw8 center items-center-l">
            <a class="db v-mid link dim w-100 w-25-l tc tl-l mb2 mb0-l white" href="/" title="codewithstyle.info">
                <img src="https://codewithstyle.info/wp-content/uploads/2017/07/CODE-WITHSTYLE-1.png" class="dib h3" alt="codewithstyle.info">
            </a>
            <div class="db v-mid w-100 w-75-l tc tr-l">
                
                    <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/" title="Home">
                        Home
                    </a>
                
                    <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/functional-programming" title="Functional Programming">
                        Functional Programming
                    </a>
                
                    <a class="link dim f6 f5-l dib mr3 mr4-l white" href="/archives" title="Archives">
                        Archives
                    </a>
                
                    <a class="link dim f6 f5-l dib mr3 mr4-l white" href="http://miloszpiechocki.com/" title="Author">
                        Author
                    </a>
                
            </div>
        </nav>
    </div>

    <!-- Title -->
    <div class="w-100 vh-40 dt">
        <div class="v-mid white center mw8">
            <h1 class="f1-l f2-m tc tc-m tl-ns">Advanced functional programming in TypeScript: Maybe monad</h1>
            <p class="f4 fw3 pab-100px tc tc-m tl-ns">2018-02-19</p>
        </div>
    </div>

    <!-- Icon -->
    <div class="relative w-100 mw8 center white dn dn-m db-ns">
        <i class="header-icon "></i>
    </div>
</div>

<!-- Content -->
<div class="w-100 ph2 ph4-m ph5-l mv5 mv6-l">
    <div class="content">
        <div class="mw8 center">
            <div class="cf">
                <div class="fl w-100 w-70-l mw7 left fw3 lh-copy pr4-ns pr0-m post-content">
                    <!-- Tags Vertical -->
                    

                    <!-- Main Post Content -->
                    <p>With this post, I would like to start a short series about <strong>monads</strong>. If you are familiar with some functional programming techniques in JavaScript (such as immutability or pure functions), this is a great next step to go deeper into this amazing paradigm. Regardless of whether you’ve never heard about monads or have heard about them but never really understood them, this series will strive to explain then in simple, practical terms. <img src="https://codewithstyle.info/wp-content/uploads/2018/02/Monads-part1.png" alt=""> I’ve already tackled this topic on the blog a few times (see <a href="https://codewithstyle.info/understand-monads-linq/">monads in C#</a> and <a href="https://codewithstyle.info/scalas-option-monad-versus-null-conditional-operator-in-c/">monads in Scala</a>) but this time I would like to explore how monads can be useful in the front-end world. One final word - I chose TypeScript over JavaScript because it’s just easier to talk about monads in a strongly-typed language. You don’t have to be a TypeScript expert to understand the article. <strong>You can find all the code from the series in <a href="https://github.com/miloszpp/typescript-monads" target="_blank" rel="noopener">this repository</a>. Check the commit history for code relevant to the specific part of the series.</strong> Let’s get ready for our monadic journey!</p>
<h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><p>We’re going to build a simple application that implements the following scenario: <em>A company has a hierarchical employee structure (each employee can have another employee as a supervisor). As a user, I would like to be able to enter employee ID (a numeric value) and see their supervisor’s name.</em> Let’s start with a plain, non-monadic implementation. Here is some HTML for the user interface:</p>
<pre><code>&lt;body&gt;
    &lt;h1&gt;Find employee&apos;s supervisor&lt;/h1&gt;
    &lt;p&gt;
        &lt;label for=&quot;employeeId&quot;&gt;Enter employee ID&lt;/label&gt;
        &lt;input type=&quot;text&quot; name=&quot;employeeId&quot; id=&quot;employeeIdInput&quot; /&gt;
    &lt;/p&gt;
    &lt;p&gt;
        &lt;button type=&quot;button&quot; id=&quot;findEmployeeButton&quot;&gt;Find supervisor&apos;s name&lt;/button&gt;
    &lt;/p&gt;
    &lt;p id=&quot;searchResults&quot;&gt;&lt;/p&gt;
&lt;/body&gt;
</code></pre><p>The HTML consists of an input for the employee’s ID and a button to search for the employee’s supervisor’s name. And here comes the code that orchestrates this form:</p>
<pre><code>import { EmployeeRepository } from &quot;./employee.repository&quot;;

const employeeIdInputEl = document.getElementById(&quot;employeeIdInput&quot;) as HTMLInputElement;
const findEmployeeButtonEl = document.getElementById(&quot;findEmployeeButton&quot;);
const searchResultsEl = document.getElementById(&quot;searchResults&quot;);

const repository = new EmployeeRepository();

findEmployeeButtonEl.addEventListener(&quot;click&quot;, () =&gt; {
    const supervisorName = getSupervisorName(employeeIdInputEl.value);
    if (supervisorName) {
        searchResultsEl.innerText = `Supervisor name: ${supervisorName}`;
    } else {
        searchResultsEl.innerText = &quot;Could not find supervisor for given id&quot;;
    }
});

function getSupervisorName(enteredId: string) {
    if (enteredId) {
        const employee = repository.findById(parseInt(enteredId));
        if (employee &amp;&amp; employee.supervisorId) {
            const supervisor = repository.findById(employee.supervisorId);
            if (supervisor) {
                return supervisor.name;
            }
        }
    }
}
</code></pre><p>Firstly, we get hold of some HTML elements. Next, we attach a click handler to the button. Inside the handler, we invoke the <code>getSupervisorName</code> function which holds all of the actual logic (we will get back to it soon). Finally, we update the <code>p</code> tag with search results. Finally, let’s have a quick look at the <code>EmployeeRepository</code> class:</p>
<pre><code>import { Employee } from &quot;./employee.model&quot;;

export class EmployeeRepository {
    private employees: Employee[] = [
        { id: 1, name: &quot;John&quot; },
        { id: 2, name: &quot;Jane&quot;, supervisorId: 1 },
        { id: 3, name: &quot;Joe&quot;, supervisorId: 2 },
    ];

    findById(id: number) {
        const results = this.employees.filter(employee =&gt; employee.id === id);
        return results.length ? results[0] : null;
    }
}
</code></pre><p>It’s just an in-memory storage of the employee hierarchy with some hardcoded values. The <code>Employee</code> interface could look like this:</p>
<pre><code>export interface Employee {
    id: number;
    name: string;
    supervisorId?: number;
}
</code></pre><h2 id="Nesting-nesting-nesting"><a href="#Nesting-nesting-nesting" class="headerlink" title="Nesting, nesting, nesting"></a>Nesting, nesting, nesting</h2><p>As promised, let’s focus on the <code>getSupervisorName</code> function.</p>
<pre><code>function getSupervisorName(enteredId: string) {
    if (enteredId) {
        const employee = repository.findById(parseInt(enteredId));
        if (employee &amp;&amp; employee.supervisorId) {
            const supervisor = repository.findById(employee.supervisorId);
            if (supervisor) {
                return supervisor.name;
            }
        }
    }
}
</code></pre><p>As we can see, the function body involves several levels of nesting. This is because many things can go wrong during the search for the supervisor.</p>
<ul>
<li>the user can click the button without typing anything in the ID field</li>
<li>there can be no employee for given ID</li>
<li>the employee we’re looking for can have no supervisor (e.g. they’re a CEO or an independent consultant)</li>
<li>there can be no employee with ID equal to the employee’s supervisor’s ID (inconsistency in the hierarchy)</li>
</ul>
<p>In other words, there are many operations involved and each of them can return an <strong>empty result</strong> (e.g. <strong>empty</strong> input field, <strong>empty</strong> search result, etc.). The function needs to handle all of these edge cases and hence the deep nesting of <code>if</code> statements. Is there anything wrong with it? I think yes:</p>
<ul>
<li>when writing such code, it’s easy to miss some of the edge cases and the compiler won’t stop us from doing so</li>
<li>such code is not very readable</li>
</ul>
<p>Let’s see how to solve both of these problems. [yikes-mailchimp form=”1” description=”1”]</p>
<h2 id="Introducing-Maybe"><a href="#Introducing-Maybe" class="headerlink" title="Introducing Maybe"></a>Introducing <code>Maybe</code></h2><p>One way of simplifying code is to identify a pattern and create an abstraction that hides the implementation details of this pattern. The recurring theme in the <code>getSupervisorName</code> function is the nesting of <code>if</code> statements.</p>
<pre><code>if (result) {
  const nextResult = operation(result);
  if (nextResult) {
     // and so on...
  }
} // else stop
</code></pre><p>But how to create an abstraction over such a pattern? The reason we have to do these <code>if</code> checks is that the value stored inside <code>result</code> can be empty. We’ll create a simple wrapper type that holds a simple value and is aware of whether the value is empty (ie. <code>null</code> or <code>undefined</code> or empty string) or not. Let’s call this wrapper type <code>Maybe</code>.</p>
<pre><code>export class Maybe&lt;T&gt; {
    private constructor(private value: T | null) {}

    static some&lt;T&gt;(value: T) {
        if (!value) {
            throw Error(&quot;Provided value must not be empty&quot;);
        }
        return new Maybe(value);
    }

    static none&lt;T&gt;() {
        return new Maybe&lt;T&gt;(null);
    }

    static fromValue&lt;T&gt;(value: T) {
        return value ? Maybe.some(value) : Maybe.none&lt;T&gt;();
    }

    getOrElse(defaultValue: T) {
        return this.value === null ? defaultValue : this.value;
    }
}
</code></pre><p>Instances of <code>Maybe</code> hold a <code>value</code> that can either be an actual value or <code>null</code>. Here, <code>null</code> is the internal representation of an empty value. The constructor is private so you can only create <code>Maybe</code> instances by calling <code>some</code> or <code>none</code> static methods. <code>fromValue</code> is a convenience method that transforms a regular value to a <code>Maybe</code> instance. Finally, <code>getOrElse</code> is a safe way of extracting the value contained by <code>Maybe</code>. The caller has to provide the default value that will be used in case <code>Maybe</code> is empty. So far, so good. We can now explicitly say that the result returned by some method can be empty. Let’s change the <code>findById</code> method on <code>EmployeeRepository</code>:</p>
<pre><code>findById(id: number): Maybe&lt;Employee&gt; {
    const results = this.employees.filter(employee =&gt; employee.id === id);
    return results.length ? Maybe.some(results[0]) : Maybe.none();
}
</code></pre><p>Note that the return type of <code>findById</code> is now more meaningful and better captures the programmer’s intention. <code>findById</code> can indeed return an empty value if an employee with given ID doesn’t exist inside the repository. What’s more, we can change the <code>Employee</code> interface to explicitly state the fact that <code>supervisorId</code> can be empty:</p>
<pre><code>export interface Employee {
    id: number;
    name: string;
    supervisorId: Maybe&lt;number&gt;;
}
</code></pre><p>We’ll now add some operations to make <code>Maybe</code> type more useful. You know the <code>map</code> method that you can call on arrays, right? It applies a given function to every element of an array. If we look at <code>Maybe</code> as at a special array that can have from zero to one elements, it turns out that defining <code>map</code> on it totally makes sense.</p>
<pre><code>map&lt;R&gt;(f: (wrapped: T) =&gt; R): Maybe&lt;R&gt; {
    if (this.value === null) {
        return Maybe.none&lt;R&gt;();
    } else {
        return Maybe.some(f(this.value));
    }
}
</code></pre><p>Our <code>map</code> takes a function <code>f</code> that transforms the element wrapped by <code>Maybe</code> and returns a new <code>Maybe</code> with the result of the transformation. If <code>Maybe</code> was a <code>none</code> then the result of <code>map</code> will also be an empty <code>Maybe</code> (just like calling <code>map</code> on an empty array would give you an empty array). <code>R</code> is the type parameter representing the type returned by <code>f</code> transformation. But how is this <code>map</code> useful? The original version of the <code>getSupervisorName</code> function included the below <code>if</code> statement:</p>
<pre><code>const supervisor = repository.findById(employee.supervisorId);
if (supervisor) {
    return supervisor.name;
}
</code></pre><p>But <code>findById</code> returns a <code>Maybe</code> now! And we have the <code>map</code> operation available which, accidentally, has exactly the same semantics as the <code>if</code> statement above! Therefore, we can rewrite the above piece like this:</p>
<pre><code>const supervisor: Maybe&lt;Employee&gt; = repository.findById(employee.supervisorId);
return supervisor.map(s =&gt; s.name);
</code></pre><p>Didn’t we just hide the <code>if</code> statement behind an abstraction? Yes, we did! However, we’re not ready to rewrite the whole function in such style yet.</p>
<h2 id="Maybe-map-or-maybe-flatMap"><a href="#Maybe-map-or-maybe-flatMap" class="headerlink" title="Maybe map, or maybe flatMap?"></a>Maybe <code>map</code>, or maybe <code>flatMap</code>?</h2><p>Using <code>map</code> works fine for transformations such as above. But how about this one?</p>
<pre><code>const employee = repository.findById(parseInt(enteredId));
if (employee &amp;&amp; employee.supervisorId) {
    const supervisor = repository.findById(employee.supervisorId);
    // ...
}
</code></pre><p>We could try to rewrite it using <code>map</code>:</p>
<pre><code>const employee: Maybe&lt;Employee&gt; = repository.findById(parseInt(enteredId));
const supervisor: Maybe&lt;Maybe&lt;Employee&gt;&gt; = employee.map(e =&gt; repository.findById(e.supervisorId));
</code></pre><p>See the problem? The type of <code>supervisor</code> is <code>Maybe&lt;Maybe&lt;Employee&gt;&gt;</code>. This is because our transformation function now maps from a regular value to a <code>Maybe</code> (and previously it was mapping from regular value to a regular value). Is there a way to transform <code>Maybe&lt;Maybe&lt;Employee&gt;&gt;</code> to a simple <code>Maybe&lt;Employee&gt;</code>? In other words, we would like to <strong>flatten</strong> our <code>Maybe</code>. Again, there is an analogy to arrays. You can flatten nested array <code>[[1, 2, 3], [4, 5, 6]]</code> to <code>[1, 2, 3, 4, 5, 6]</code>. We’ll add a new operation to <code>Maybe</code> and call it <code>flatMap</code>. It’s just like <code>map</code> but it also flattens the result so that we don’t end up with nested <code>Maybe</code>s.</p>
<pre><code>flatMap&lt;R&gt;(f: (wrapped: T) =&gt; Maybe&lt;R&gt;): Maybe&lt;R&gt; {
    if (this.value === null) {
        return Maybe.none&lt;R&gt;();
    } else {
        return f(this.value);
    }
}
</code></pre><p>The implementation is pretty simple. If given instance of <code>Maybe</code> is not empty then we extract the wrapped value, apply the provided function and simply return the result (which can either be empty or not empty). If the instance was empty, we simply return an empty <code>Maybe</code>. Note the type signature of <code>f</code>. Previously, it was mapping from <code>T</code> to <code>R</code>. Now, it’s mapping from <code>T</code> to <code>Maybe&lt;R&gt;</code>. Thanks to the addition of <code>flatMap</code>, we can now rewrite the above code piece like this:</p>
<pre><code>const employee: Maybe&lt;Employee&gt; = repository.findById(parseInt(enteredId));
const supervisor: Maybe&lt;Employee&gt; = employee.flatMap(e =&gt; repository.findById(e.supervisorId));
</code></pre><h2 id="Maybe-Monad-in-action"><a href="#Maybe-Monad-in-action" class="headerlink" title="Maybe Monad in action"></a>Maybe Monad in action</h2><p>Now, we’ve got all we need to rewrite the <code>getSupervisorName</code> function.</p>
<pre><code>function getSupervisorName(maybeEnteredId: Maybe&lt;string&gt;): Maybe&lt;string&gt; {
    return maybeEnteredId
        .flatMap(employeeIdString =&gt; Maybe.fromValue(parseInt(employeeIdString))) // parseInt can fail
        .flatMap(employeeId =&gt; repository.findById(employeeId))
        .flatMap(employee =&gt; employee.supervisorId)
        .flatMap(supervisorId =&gt; repository.findById(supervisorId))
        .map(supervisor =&gt; supervisor.name);
}
</code></pre><p>We’ve eliminated all of the nested <code>if</code> statements! The <code>getSupervisorName</code> function’s body is now an elegant pipeline of transformations applied to the input value. We’ve hidden the details of handling empty results because they’re just boilerplate and obfuscate the real intention of the code. They’re now taken care of by <code>Maybe</code>. Note that if any of the operations inside <code>flatMap</code> returned a <code>none</code>, it would cause the whole thing to immediately return a <code>none</code>. This is actually the same behaviour that we had with nested <code>if</code> statements. Here is an example of how the function can be used inside the click handler:</p>
<pre><code>findEmployeeButtonEl.addEventListener(&quot;click&quot;, () =&gt; {
    const supervisorName = getSupervisorName(Maybe.fromValue(employeeIdInputEl.value));
    searchResultsEl.innerText = `Supervisor name: ${supervisorName.getOrElse(&quot;could not find&quot;)}`;
});
</code></pre><p>And, guess what, <code>Maybe</code> is a <strong>monad</strong>! The formal definition of a monad is that it’s a container type that has two operations:</p>
<ul>
<li><code>return</code> - which creates an instance of the type from a regular value (<code>some</code> and <code>none</code> in our case)</li>
<li><code>bind</code> - which lets you combine monadic values (<code>flatMap</code> in our case)</li>
</ul>
<p>There are also some monadic laws that every monad has to follow but let’s not dive into it yet. For now, you have to trust me that our <code>Maybe</code> implementation follows these laws :)</p>
<h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>In this first post of the series, we’ve created our first monad. The purpose of the <code>Maybe</code> monad is to abstract away handling of empty values. Thanks to the introduction of this type, we can now write code without having to worry about empty results. In the next article, we’ll see how thanks to TypeScript we can write code that uses monads in an even more readable way. Do you find monads interesting? Do you feel like you understand the concept now or is it still a mystery? <strong>Please let me know in comments!</strong></p>

                    
                    <!-- Tags Bottom -->
                    

                    <!-- Comments -->
                    



                </div>
                <div class="fl w-100 w-30-l center fw3 lh-copy pl4-ns tl black-50">
                    
                    <hr class="dn-l mw4 black-50 mt5">
                    
                    <div class="mt5 mt0-l">
    <article class="dt db-l mw8 mw8-m mw5-ns center ml0-l bg-white mv3">
        <div class="dn dtc-m db-l v-mid tc pr4 pr0-l" style="min-width: 6rem;">
            <img src="https://codewithstyle.info/wp-content/uploads/2017/02/miloszpiechocki.jpeg" class="mb4-l br-100 h3 w3 h4-l w4-l dib" title="Miłosz Piechocki">
        </div>
        <div class="dtc db-l v-mid lh-copy measure center f6 black-50 tj">
            Hi! My name is Miłosz Piechocki. I’m a software developer living in Warsaw, Poland. I’m passionate about functional programming and in particular how it’s applied in modern web technologies.
        </div>
    </article>
</div>

                    <hr class="dn-l mw4 black-50 mt5">

                    <div class="mt5 tc tl-l">
    <h3>Download free e-book</h3>
    <p class="tj f6 lh-copy">Subscribe to receive updates about new posts and I will send you a link to a free e-book about functional programming in JavaScript.</p>
    <!-- Begin Mailchimp Signup Form -->
    <div id="mc_embed_signup">
        <form action="https://codewithstyle.us15.list-manage.com/subscribe/post?u=9387aca2477532e2e033cee17&amp;id=7c51853ca5" method="post" id="mc-embedded-subscribe-form" name="mc-embedded-subscribe-form" class="validate" target="_blank" novalidate="">
            <div id="mc_embed_signup_scroll">
                <div class="mc-field-group">
                    <input class="pa2 input-reset ba bg-transparent w-100" type="email" value="" name="EMAIL" id="mce-EMAIL" placeholder="enter your email">
                </div>
                <div id="mce-responses" class="clear">
                    <div class="response" id="mce-error-response" style="display:none"></div>
                    <div class="response" id="mce-success-response" style="display:none"></div>
                </div>    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->
                <div style="position: absolute; left: -5000px;" aria-hidden="true"><input type="text" name="b_9387aca2477532e2e033cee17_7c51853ca5" tabindex="-1" value=""></div>
                <div class="clear mt2">
                    <input class="b ph3 pv2 input-reset ba b--black bg-transparent grow pointer f6 dib" type="submit" value="Subscribe" name="subscribe" id="mc-embedded-subscribe">
                </div>
            </div>
        </form>
    </div>
    <!--End mc_embed_signup-->
</div>

                    
                </div>
            </div>
        </div>
    </div>
</div>


<!-- Footer -->
<div class="bg-1 ph2 ph5-ns pv5">
        <div class="mv8">
            <div class="center tc">
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="http://twitter.com/miloszpp/" target="_blank">
                            <i class="fab fa-twitter"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="http://facebook.com/codewithstyle.info/" target="_blank">
                            <i class="fab fa-facebook"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://github.com/miloszpp" target="_blank">
                            <i class="fab fa-github"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="https://www.youtube.com/channel/UC_DEBDpgRyBZAT85tJ1QZBw" target="_blank">
                            <i class="fab fa-youtube"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="mailto:milosz@miloszpiechocki.com" target="_blank">
                            <i class="fas fa-envelope"></i>
                        </a>
                    </div>
                
                    <div class="dib mh3">
                        <a class="f3 f2-ns white dim" href="/#" target="_blank">
                            <i class="fas fa-rss"></i>
                        </a>
                    </div>
                
            </div>
            <div class="f6 f5-ns center tc white pt5 fw3">
                @Copyright Miłosz Piechocki. All right reserved | Design & Hexo based on Anodyne by <a class="link dim white" href="http://www.codeblocq.com/">Jonathan Klughertz</a>
            </div>
        </div>
    </div>

<!-- After Footer -->
<!-- Disqus Comments -->



</body>

</html>